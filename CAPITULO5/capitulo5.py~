#!/usr/bin/env python3
'''modulos'''

# importar modulo

import sys

print ('VERSION en uso de  PYTHON\n')

print (sys.version,'\n')

print ('¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬\n')

print ('importar un modulo -import nombreDELmodulo- ; import sys \n')

print ('importar multiples modulos -import nombreDELmodulo,nombreDELmodulo1,...- ; import collections,os.path \n')

import collections,os.path # importa el modulo indicado y el modulo path del paquete de modulos os
 
print ('importar un modulo y cambiar su nombre -import nombreDELmodulo as nuevoNombre- ; import sys as SISTEMA \n')

import sys as SISTEMA # importa el modulo indicado y lo renombra como SISTEMA

print ('SISTEMA.version \n')

print (SISTEMA.version,'\n') # presenta la version en uso de python

print ('importar una funcion del modulo -from nombreDELmodulo import nombreFuncion- ; from sys import version \n')

from sys import version # importa la funcion del modulo indicado

print ('version \n')

print(version,'\n') # presenta la version en uso de python

print ('importar una funcion del modulo y cambiarle el nombre -from nombreDELmodulo import nombreFuncion as nuevoNombre- ; from sys import version as versionPYTHON \n')

from sys import version as versionPYTHON  # importa la funcion del modulo indicado y le cambia el nombre al indicado

print ('versionPYTHON \n')

print (versionPYTHON,'\n') # presenta la version en uso de python

print ('importar multiples funciones de un modulo -from nombreDELmodulo import nombreFuncion,nombreFuncion1,...- ; from sys import float_info,getdefaultencoding,getfilesystemencoding \n')

from sys import float_info,getdefaultencoding,getfilesystemencoding #  importa las funciones  del modulo indicado

print ('float_info.epsilon ',float_info.epsilon,'\n') # presenta la constante de epsilon

print ('getdefaultencoding () ',getdefaultencoding(),'\n')  # presenta la codificacion unicode del script python

print ('getfilesystemencoding () ',getfilesystemencoding(),'\n') # presenta la codificacion de los ficheros -depende del sistema operativo-

print ('importar todas las funciones de un modulo -from nombreDELmodulo import *- ; NO USAR , PUEDE PROVOCAR CONFLICTOS CON FUNCIONES DE OTROS MODULOS \n')

print ('crear e identificar paquetes de modulos -uso de __init__.py- ; nombreDirectorio / __init__.py   nombremodulo.py .... \n')

print ('llamar a los modulos de un paquete -from nombreDirectorioPaquete import nombreDELmodulo- ; from directorioPaquetesPYTHON.paquete1 import moduloA,moduloB,moduloC \n')

from directorioPaquetesPYTHON.paquete1 import moduloA,moduloB,moduloC # importa los modulos indicados del paquete directorioPaquetesPYTHON.paquete1

print ('llamar a los modulos del paquete indicado \n')

print ('moduloA.iniciar () ',moduloA.iniciar ()) # llama a la funcion del modulo y presenta el valor devuelto 

print ('moduloB.iniciar () ',moduloB.iniciar ()) # llama a la funcion del modulo y presenta el valor devuelto 

print ('moduloC.iniciar () ',moduloC.iniciar ()) # llama a la funcion del modulo y presenta el valor devuelto 

print ('importar modulo utilidadesTexto del paquete de modulos ; paquete2 -uso de from / import- ; from directorioPaquetesPYTHON.paquete2 import utilidadesTexto \n')

from directorioPaquetesPYTHON.paquete2 import utilidadesTexto # importa el modulo indicado del paquete2

print ('documentacion del modulo ; utilidadesTexto.__doc__ \n')

print(utilidadesTexto.__doc__ ) # presenta la documentacion del modulo

print ("utilidadesTexto.simplificarTexto ('este        es           el texto a    simplicar') ",utilidadesTexto.simplificarTexto ('este        es           el texto a    simplicar'),'\n') # presenta la cadena , llama a la funcion con el argumento indicado y presenta el resultado

print ("utilidadesTexto.simplificarTexto ('este        es           el texto a    simplicar',borrar='\\n') ",utilidadesTexto.simplificarTexto ('este        es           el texto a    simplicar',borrar='\n'),'\n') # presenta la cadena , llama a la funcion con el argumento indicado y presenta el resultado

print ("utilidadesTexto.simplificarTexto ('este        es           el texto a    simplicar',borrar='e') ",utilidadesTexto.simplificarTexto ('este        es           el texto a    simplicar',borrar='e'),'\n') # presenta la cadena , llama a la funcion con el argumento indicado y presenta el resultado

print ("utilidadesTexto.simplificarTexto ('este        es           el texto a    simplicar',borrar='eaio') ",utilidadesTexto.simplificarTexto ('este        es           el texto a    simplicar',borrar='eaio'),'\n') # presenta la cadena , llama a la funcion con el argumento indicado y presenta el resultado

print ("utilidadesTexto.emparejado ('(este)       [es]          { el texto a}    <simplicar>') ",utilidadesTexto.emparejado ('(este)       [es]          { el texto a}    <simplicar>'),'\n') # presenta la cadena , llama a la funcion con el argumento indicado y presenta el resultado

print ("utilidadesTexto.emparejado ('(este)       es           el texto a    simplicar') ",utilidadesTexto.emparejado ('(este)       es           el texto a    simplicar'),'\n') # presenta la cadena , llama a la funcion con el argumento indicado y presenta el resultado

print ("utilidadesTexto.emparejado ('(este)       (es)           el texto a    simplicar') ",utilidadesTexto.emparejado ('(este)       (es)           el texto a    simplicar'),'\n') # presenta la cadena , llama a la funcion con el argumento indicado y presenta el resultado

print ("utilidadesTexto.emparejado ('(este)       (es)           (el texto a    simplicar') ",utilidadesTexto.emparejado ('(este)       (es)           el texto a    simplicar'),'\n') # presenta la cadena , llama a la funcion con el argumento indicado y presenta el resultado

print ("utilidadesTexto.emparejado ('([{<>}])') ",utilidadesTexto.emparejado ('([{<>}])'),'\n') # presenta la cadena , llama a la funcion con el argumento indicado y presenta el resultado

print ("utilidadesTexto.acortadorTexto ('este es el texto a ACORTAR',14) ",utilidadesTexto.acortadorTexto ('este es el texto a ACORTAR',14),'\n') # presenta la cadena , llama a la funcion con el argumento indicado y presenta el resultado

print ("utilidadesTexto.acortadorTexto ('este es el texto a ACORTAR',12) ",utilidadesTexto.acortadorTexto ('este es el texto a ACORTAR',12),'\n') # presenta la cadena , llama a la funcion con el argumento indicado y presenta el resultado

print ("utilidadesTexto.acortadorTexto ('este es el texto a ACORTAR',10) ",utilidadesTexto.acortadorTexto ('este es el texto a ACORTAR',10),'\n') # presenta la cadena , llama a la funcion con el argumento indicado y presenta el resultado

print ("utilidadesTexto.acortadorTexto ('este es el texto a ACORTAR',7) ",utilidadesTexto.acortadorTexto ('este es el texto a ACORTAR',7),'\n') # presenta la cadena , llama a la funcion con el argumento indicado y presenta el resultado

print ('importar modulo ventanaFormatoTexto del paquete de modulos ; paquete2 -uso de from / import- ; from directorioPaquetesPYTHON.paquete2 import ventanaFormatoTexto \n')

from directorioPaquetesPYTHON.paquete2 import ventanaFormatoTexto # importa el modulo indicado del paquete2

print ('documentacion del modulo ; ventanaFormatoTexto.__doc__ \n')

print(ventanaFormatoTexto.__doc__ ) # presenta la documentacion del modulo

print ('modulos propios python : modulo string ; import string \n')

import string # importa el modulo indicado

print ('constante ascii_letters del modulo string ; string.ascii_letters ',string.ascii_letters,'\n') # presenta las letras en ascii  

print ('constante hexdigits del modulo string ; string.hexdigits ',string.hexdigits,'\n') # presenta los digitos en hexadecimal

print ('clase Formatter del modulo string ; string.Formatter().format ("abcde1234567890","A","B","C","D","E","F","G",a=1,b=2,c=3,d=4,e=5) \n')

string.Formatter().format ("abcde1234567890","A","B","C","D","E","F","G",a=1,b=2,c=3,d=4,e=5) # crea un mini formato con las cadenas indicadas

print ('modulos propios python : modulo textwrap ; import textwrap \n')

import textwrap # importa el modulo indicado

print ('acortar y reemplazar texto con la funcion shorten del modulo textwrap ; textwrap.shorten ("esta es la cadena a acortar",26,placeholder=" ++++\\n") \n')

print (textwrap.shorten ("esta es la cadena a acortar",26,placeholder=" ++++\n")) # presenta la cadena acortada en el ultimo espacio del ancho indicado y sustituyendo por la cadena indicada 

print ('modulos propios python : modulo struct ; import struct \n')

import struct # importa el modulo indicado

print ('empaquetar en una estructura indicada con la funcion pack del modulo struct ; struct.pack ("hhl",1,2,3) \n')

print (struct.pack ("hhl",1,2,3),'\n') # presenta los numeros indicados empaquetados en una estructura ; 'numeroEnterocortonumeroEnterocortonumeroEnterolargo'
 
print (r'desempaquetar en una estructura indicada con la funcion unpack del modulo struct ; struct.unpack ("hhl",b"\x01\x00\x02\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00")',' \n')

print (struct.unpack ("hhl",b"\x01\x00\x02\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00"),'\n') # presenta los numeros binarios indicados desempaquetados en una estructura base decimal ; 'numeroEntero,numeroEntero,numeroEntero'

print ('modulos propios python : modulo difflib ; import difflib \n')

import difflib # importa el modulo indicado

print ('devolver coincidencias entre cadenas con la funcion get_close_matches del modulo difflib ; difflib.get_close_matches ("manzana",["manzana","man","m","fruta","arbol","agricultura"])\n')

print (difflib.get_close_matches ("manzana",["manzana","man","m","fruta","arbol","agricultura"]),'\n') # presenta las coincidencias con el primer parametro

print ('modulos propios python : modulo io ; import io \n')

import io # importa el modulo indicado

print ('procesar una cadena como un archivo de texto en memoria con la clase StringIO del modulo io ; salida = io.StringIO () \n')

salida = io.StringIO () # crea el objeto StringIO -como archivo en memoria-

print (r'escribir una cadena en el objeto salida ; salida.write ("esta es la cadena enviada a io.StringIO () \n") ','\n')

salida.write ("esta es la cadena enviada a io.StringIO () \n") # escribe la cadena en el objeto 

print (r'escribir una segunda cadena en el objeto salida ; salida.write ("esta es la segunda cadena enviada a io.StringIO () \n") ','\n')

salida.write ("esta es la segunda cadena enviada a io.StringIO () \n") # escribe la cadena en el objeto

print (r'mandar una cadena mediante la funcion print ; print ("esta es la cadena enviada con la funcion print \n",file=salida) ','\n')

print ("esta es la cadena enviada con la funcion print \n",file=salida) # cadena enviada con la funcion print a salida -no se muestra en terminal-

print ('mostrar contenido del objeto salida ; contenido = salida.getvalue () \n')

contenido = salida.getvalue () # devuelve todas las cadenas almacenadas en el objeto

print ('presenta contenido \n')

print (contenido) # presenta las cadenas devueltas por getvalue () del objeto salida

print ('cerrar el objeto salida de io.StringIO () con close ; salida.close () \n')

salida.close () # cierra el objeto salida

print (r'volver a escribir una cadena en el objeto salida ; salida.write ("esta es otra cadena enviada a io.StringIO () \n") ','\n')

try : # control de excepciones
	salida.write ("esta es otra cadena enviada a io.StringIO () \n") # escribe la cadena en el objeto 
except ValueError as error : # tipo de excepcion , pasa la salida a error
	print ('+++ objeto CERRADO +++ {0} \n'.format (error)) # presenta la cadena formateada con la salida de error

print ('modulos propios python : modulo fileinput ; import fileinput \n')

import fileinput # importa el modulo indicado

print ('procesar texto redireccionado al terminal de un fichero o de la entrada estandard -stdin- con la funcion input del modulo fileinput ; textoRedireccionado = fileinput.input ("./Escritorio/capitulo5.py~") \n')

textoRedireccionado = fileinput.input ("./Escritorio/capitulo5.py~") # redirecciona el contenido del fichero indicado en una sola secuencia continua de lineas al terminal

print  ('leer contenido de la linea -uso de la funcion readline para ficheros- ; textoRedireccionado.readline () \n')

textoRedireccionado.readline () # lee la primera linea -la secuencia continua-

print ('nombre del fichero del objeto textoRedireccionado con la funcion filename del modulo fileinput ; textoRedireccionado.filename () \n') 

print (textoRedireccionado.filename (),'\n') # presenta el nombre del fichero del objeto fileinput

print ('numero de linea actual leida del objeto textoRedireccionado con la funcion lineno del modulo fileinput ; textoRedireccionado.lineno () ',textoRedireccionado.lineno (),'\n') # presenta el numero de linea leido actual

print ('modulos propios python : modulo getopt ; import getopt \n')

import getopt # importa el modulo indicado

print ('argumentosOPCIONALES = ["-c","-b","-a","-Ttest","-x","valor","--condicion=opcion","--test","--salidaFichero","fichero","argumento1","argumento2"] \n')

argumentosOPCIONALES = ["-c","-b","-a","-Ttest","-x","valor","--condicion=opcion","--test","--salidaFichero","fichero","argumento1","argumento2"] # lista de argumentos opcionales para el script

print ('nombresCortosOPCIONES = "cbaT:x:" \n')

nombresCortosOPCIONES = "cbaT:x:" # cadena nombres cortos de comandos opcionales para el script

print ('nombresLargosOPCIONES = ["condicion=","test","salidaFichero="] \n')

nombresLargosOPCIONES = ["condicion=","test","salidaFichero="] # lista nombres largos de comandos opcionales para el script

print ('crear comandos opcionales de linea para el script usando la funcion getopt del modulo getopt ;  \n')

print ('desempaquetar opciones y argumentos ; listaOPCIONES,ARGUMENTOS = getopt.getopt (argumentosOPCIONALES,nombresCortosOPCIONES,nombresLargosOPCIONES) \n')

listaOPCIONES,ARGUMENTOS = getopt.getopt (argumentosOPCIONALES,nombresCortosOPCIONES,nombresLargosOPCIONES) # añade opciones al script ,opciones a listaOPCIONES y argumentos a ARGUMENTOS

print ('listaOPCIONES ; ',listaOPCIONES,'\n') # presenta la lista de comandos opcionales de linea

print ('ARGUMENTOS ; ',ARGUMENTOS,'\n') # presenta la lista de argumentos de los comandos 

print ('modulos propios python : modulo optparse ; import optparse \n')

import optparse # importa el modulo indicado

print ('crear objeto para comandos opcionales en linea usando la clase OptionParser del modulo optparse ; comandosOPCIONES = optparse.OptionParser () \n') 

comandosOPCIONES = optparse.OptionParser () # crea el objeto de comandos opcionales para el script

print ('añadir comandos opcionales al script con la funcion add_option del objeto comandosOPCIONES ; \n')

print (r'comandosOPCIONES.add_option ("-f","--formato",dest="formato",help="uso del comando opcional corto -f o largo --formato para indicar el formato\n")','\n')

comandosOPCIONES.add_option ("-f","--formato",dest="formato",help="uso del comando opcional corto -f o largo --formato para indicar el formato\n") # añade los comandos opcionales al script

print (r'comandosOPCIONES.add_option ("-s","--salir",dest="exit",help="uso del comando opcional corto -s o largo --salir para indicar la salida del script\n")','\n')

comandosOPCIONES.add_option ("-s","--salir",dest="exit",help="uso del comando opcional corto -s o largo --salir para indicar la salida del script\n") # añade los comandos opcionales al script

print (r'comandosOPCIONES.add_option ("-a","--archivo",dest="fichero",help="uso del comando opcional corto -a o largo --archivo para indicar añadir datos al fichero\n")','\n')

comandosOPCIONES.add_option ("-a","--archivo",dest="fichero",help="uso del comando opcional corto -a o largo --archivo para indicar añadir datos al fichero\n") # añade los comandos opcionales al script

print ('desempaquetar opciones y argumentos con la funcion parse_args del objeto comandosOPCIONES ; ListaOpciones,Argumentos = comandosOPCIONES.parse_args () \n')

ListaOpciones,Argumentos = comandosOPCIONES.parse_args () # desempaqueta los comandos opcionales y argumentos devueltos por la funcion parse_args

print ('ListaOpciones ; ',ListaOpciones,'\n') # presenta la lista de comandos opcionales de linea

print ('Argumentos ; ',Argumentos,'\n') # presenta la lista de argumentos de los comandos 

print ('modulos propios python : modulo decimal ; import decimal \n')

import decimal # importa el modulo indicado

print ('valores por defecto del punto flotante del script usando la funcion getcontext del modulo decimal ; decimal.getcontext () \n')

print (decimal.getcontext (),'\n') # presenta los valores por defecto de las operaciones de punto flotante

print ('numeros de decimales en punto flotante de precision ; decimal.getcontext().prec ',decimal.getcontext().prec,'\n') # presenta el numero maximo de decimales en la precision del punto flotante

print ('decimal.Decimal (10) ',decimal.Decimal (10),'\n') # presenta el valor mas cercano con una precision de 28 digitos en punto flotante

print ('decimal.Decimal (3.14) ',decimal.Decimal (3.14),'\n') # presenta el valor mas cercano con una precision de 28 digitos en punto flotante

print ('decimal.Decimal (3.14) ** decimal.Decimal (2.9) ',decimal.Decimal (3.14) ** decimal.Decimal (2.9),'\n') # presenta el valor mas cercano con una precision de 28 digitos en punto flotante

print ('modulos propios python : modulo fractions ; import fractions \n')

import fractions # importa el modulo indicado

print ('operaciones con fracciones y numeros racionales ; fractions.Fraction (3/7) ',fractions.Fraction (3/7),'\n') # presenta el resultado de la operacion -fracciones-

print ('operaciones con fracciones y numeros racionales ; fractions.Fraction ("3/7") ',fractions.Fraction ("3/7"),'\n') # presenta el resultado de la operacion -fracciones-

print ('operaciones con fracciones y numeros racionales ; fractions.Fraction (3,-6) ',fractions.Fraction (3,-6),'\n') # presenta el resultado de la operacion -fracciones-

print ('modulos propios python : modulo math ; import math \n')

import math # importa el modulo indicado

print ('devolver el valor de pi con la funcion pi del modulo math ; math.pi ',math.pi,'\n') # presenta la constante pi

print ('modulos propios python : modulo cmath ; import cmath \n')

import cmath # importa el modulo indicado

print ('devolver el valor de pi con la funcion pi del modulo cmath ; cmath.pi ',cmath.pi,'\n') # presenta la constante pi

print ('modulos propios python : modulo random ; import random \n')

import random # importa el modulo indicado

print ('devolver un valor aleatorio en punto flotante -0.0 a 1.0- con la funcion random del modulo random ; random.random () ',random.random (),'\n') # presenta el valor en punto flotante aleatorio

print ('modulos propios python : modulo numbers ; import numbers \n')

import numbers # importa el modulo indicado

print ('comprobar si un objeto o numero es del tipo indicado , un numero con la funcion Number del modulo numbers ;  \n')

print ('isinstance (99,numbers.Number) ',isinstance (99,numbers.Number),'\n')

print ('isinstance (99,numbers.Rational) ',isinstance (99,numbers.Rational),'\n')

print ('isinstance (99,numbers.Integral) ',isinstance (99,numbers.Integral),'\n')

print ('isinstance (99,numbers.Complex) ',isinstance (99,numbers.Complex),'\n')

print ('modulos propios python : modulo datetime ; import datetime \n')

import datetime # importa el modulo indicado

print ('devolver fecha y hora actual con la funcion now de la clase datetime del modulo datetime \n')

print ('datetime.datetime.now () ',datetime.datetime.now (),'\n') # presenta la fecha y hora actual

print ('devolver fecha y hora actual con formato propio con la funcion strftime del modulo datetime \n')

print ('datetime.datetime.now().strftime(\'%d / %m / %Y - %H : %M : %S .%f\') ',datetime.datetime.now().strftime('%d / %m / %Y - %H : %M : %S .%f'),'\n') # presenta la fecha y hora actual en el formato propio indicado

print ('modulos propios python : modulo time ; import time \n')

import time # importa el modulo indicado

print ('devolver hora local con la funcion localtime del modulo time en formato propio con strftime ;  \n')

print ('time.strftime ("HORA >> %H : %M : %S",time.localtime ()) ',time.strftime ("HORA >> %H : %M : %S",time.localtime ()),'\n') # presenta la hora local en el formato propio indicado

print ('modulos propios python : modulo calendar ; import calendar \n')

import calendar # importa el modulo indicado

print ('crear calendario con la funcion calendar del modulo calendar ; calendario = calendar.calendar (2015) \n')

calendario = calendar.calendar (2015) # crea el objeto calendario con el modulo calendar del año indicado y devuelve un calendario

print ('calendario\n',calendario) # presenta el calendario del año indicado

print ('modulos propios python : modulo bisect ; import bisect \n')

import bisect # importa el modulo indicado

print ('buscar por secciones desde la izquierda el indice de insercion coincidente de un valor en una lista ordenada con la funcion bisect_left del modulo bisect\n')

print ('bisect.bisect_left (range (10),5) ',bisect.bisect_left (range (10),5),'\n') # presenta el indice de insercion coincidente con el valor indicado en una lista

print ('bisect.bisect_left (range (10),50) ',bisect.bisect_left (range (10),50),'\n') # presenta el indice de insercion coincidente con el valor indicado en una lista

print ('lista0a9 = [x for x in range (10)]\n') 

lista0a9 = [x for x in range (10)] # asigna una lista de numeros del 0 al 9 devuelta por range -LISTA POR COMPRESION-

print ('contenido de lista0a9 ',lista0a9,'\n') # presenta la lista de numeros

print ('buscar por secciones desde la izquierda el indice de insercion coincidente de un valor en una lista ordenada e insertar el valor con la funcion insort_left del modulo bisect\n')

print ('bisect.insort_left (lista0a9,5) \n')

bisect.insort_left (lista0a9,5) # busca e inserta el valor indicado en la lista ordenada desde la izquierda

print ('lista0a9 ',lista0a9,'\n') # presenta el contenido de la lista

print ('bisect.insort_left (lista0a9,50) \n')

bisect.insort_left (lista0a9,50) # busca e inserta el valor indicado en la lista ordenada desde la izquierda

print ('lista0a9 ',lista0a9,'\n') # presenta el contenido de la lista

print ('modulos propios python : modulo heapq ; import heapq \n')

import heapq # importa el modulo indicado

print ('convertir una lista en una pila con la funcion heapify del modulo heapq ; heapq.heapify (lista0a9) \n')

heapq.heapify (lista0a9) # convierte la lista indicada en una pila

print ('lista0a9 ',lista0a9,'\n') # presenta el contenido de la lista

print ('eliminar el elemento mas pequeño de la lista con la funcion heappop del modulo heapq ; heapq.heappop (lista0a9) ',heapq.heappop (lista0a9),'\n') # elimina y presenta el valor mas pequeño de lista y lo convierte en pila 

print ('lista0a9 ',lista0a9,'\n') # presenta el contenido de la lista

print ('PILA = [] \n')

PILA = [] # asigna una lista vacia

print ('crear una pila con la funcion heappush del modulo heapq ; heapq.heappush (PILA,(5,"resto")) \n')

heapq.heappush (PILA,(5,"resto")) # añade los elementos a la pila

print ('PILA ',PILA,'\n') # presenta el contenido de la lista

print ('heapq.heappush (PILA,(2,"trabajo")) \n')

heapq.heappush (PILA,(2,"trabajo")) # añade los elementos a la pila

print ('PILA ',PILA,'\n') # presenta el contenido de la lista

print ('heapq.heappush (PILA,(4,"estudio")) \n')

heapq.heappush (PILA,(4,"estudio")) # añade los elementos a la pila

print ('PILA ',PILA,'\n') # presenta el contenido de la lista

print ('modulos propios python : modulo collections ; import collections \n')

print ('crear una lista con la clase deque del modulo collections ; SECUENCIA = collections.deque ("abc")\n')

SECUENCIA = collections.deque ("abc") # crea una lista 

print ('SECUENCIA ',SECUENCIA,'\n') # presenta el contenido

print ('añadir un elemento al final de la lista -parte derecha- con la funcion append del modulo collections ; SECUENCIA.append ("d")\n')

SECUENCIA.append ("d") # añade el elemento en la parte derecha -final de la secuencia-

print ('SECUENCIA ',SECUENCIA,'\n') # presenta el contenido

print ('añadir un elemento al principio de la lista -parte izquierda- con la funcion appendleft del modulo collections ; SECUENCIA.appendleft ("A")\n')

SECUENCIA.appendleft ("A") # añade el elemento en la parte derecha -final de la secuencia-

print ('SECUENCIA ',SECUENCIA,'\n') # presenta el contenido

print ('añadir multiples elementos a la lista con la funcion extend del modulo collections ; SECUENCIA.extend ("efjkl")\n')

SECUENCIA.extend ("efjkl") # añade los multiples elementos de la secuencia indicada

print ('SECUENCIA ',SECUENCIA,'\n') # presenta el contenido

print ('modulos propios python : modulo array ; import array \n')

import array # importa el modulo indicado

print ('crear un array con un tipo indicado y su contenido de inicio -tipo d (float tamaño 8 bytes)- ; ARRAY = array.array ("d",[1.0,2.0,3.14])\n')

ARRAY = array.array ("d",[1.0,2.0,3.14]) # crea una coleccion del tipo d -numero flotante de 8 bytes-

print ('ARRAY ',ARRAY,'\n') # presenta el contenido

print ('añadir elementos desde una lista con la funcion fromlist del modulo array ; ARRAY.fromlist ([5.0,6.1,9.99,.1])\n')

ARRAY.fromlist ([5.0,6.1,9.99,.1]) # añade los elementos de la lista al array

print ('ARRAY ',ARRAY,'\n') # presenta el contenido

print ('insertar un elemento en la posicion indicada -indice- con la funcion insert del modulo array ; ARRAY.insert (5,7.77)\n')

ARRAY.insert (5,7.77) # inserta el elemento 7.77 en la posicion 5 del array

print ('ARRAY ',ARRAY,'\n') # presenta el contenido

print ('modulos propios python : modulo weakref ; import weakref \n')

import weakref # importa el modulo indicado

print ('crear una referencia debil de un  objeto con la funcion ref del modulo weakref ; EnlaceOBJETO = weakref.ref (ARRAY)\n')

EnlaceOBJETO = weakref.ref (ARRAY) # crea un enlace debil al objeto indicado

print ('EnlaceOBJETO () ',EnlaceOBJETO(),'\n') # presenta el contenido del enlace al objeto 

print ('devolver una lista de enlaces debiles y objetos proxy con referencia al objeto con la funcion getweakrefs del modulo weakref\n')

print ('weakref.getweakrefs (EnlaceOBJETO()) ',weakref.getweakrefs (EnlaceOBJETO()),'\n') # presenta una lista de enlaces debiles al objeto

print ('modulos propios python : modulo base64 ; import base64 \n')

import base64 # importa el modulo indicado

print ('convertir un fichero binario a codigo legible con la funcion b64encode del modulo base64 \n')

diccionarioBase64 = {} # diccionario vacio -añadir lineas binarias convertidas en base64-

for numero,lineaBinaria in enumerate(open ('./Escritorio/ficheros5/BINARIO','rb')) : # iterador , bucle for in , open abre el fichero en modo solo lectura binaria , enumerate numera el contenido binario
	diccionarioBase64 [numero] = base64.b64encode(lineaBinaria) # añade al diccionario la clave : valor -numero elemento : cadena base64-
	print (base64.b64encode(lineaBinaria),'\n') # presenta el binario codificado en base64 -codigo legible-
	print ('<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n') # cadena de separacion
	
print ('contenido del diccionarioBase64 : \n')

for lineaBase64 in diccionarioBase64.values () : # iterador , bucle for in , devuelve los valores del diccionario -clave : valor-
	print ('CODIGO EN base64 : \n') # presenta la cadena
	print (lineaBase64,'\n\n') # presenta la cadena en formato base64

print ('convertir cadenas en base64 a codigo binario con la funcion b64decode del modulo base64\n')

for LineaBase64 in diccionarioBase64.values () : # iterador , bucle for in , devuelve los valores del diccionario -clave : valor-
	print ('CODIGO EN base64 : \n') # presenta la cadena
	print (LineaBase64,'\n\n') # presenta la cadena en formato base64
	print ('CODIGO BINARIO : \n') # presenta la cadena
	print (base64.b64decode (LineaBase64),'\n\n') # presenta la cadena en formato base64 convertida a binario

print ('modulos propios python : modulo quopri ; import quopri \n')

import quopri # importa el modulo indicado

print ('codificar un fichero binario a codigo legible y guardarlo en un fichero con encode del modulo quopri : \n')

print ("quopri.encode (open('./Escritorio/ficheros5/BINARIO','rb'),open('./Escritorio/ficheros5/ficheroBASE64','wb'),True) \n")

quopri.encode (open('./Escritorio/ficheros5/BINARIO','rb'),open('./Escritorio/ficheros5/ficheroBASE64','wb'),True) # lee el fichero abierto en modo solo lectura binario , lo codifica y lo escribe en el fichero indicado en base64

print ('modulos propios python : modulo uu ; import uu \n')

import uu # importa el modulo indicado

print ('codificar un fichero binario a codigo ascii y guardarlo en un fichero con encode del modulo uu : \n')

print ("uu.encode (open('./Escritorio/ficheros5/BINARIO','rb'),open('./Escritorio/ficheros5/ficheroASCII','wb')) \n")

uu.encode (open('./Escritorio/ficheros5/BINARIO','rb'),open('./Escritorio/ficheros5/ficheroASCII','wb')) # lee el fichero binario , lo convierte a ascii y lo guarda en el fichero indicado

print ('modulos propios python : modulo xdrlib ; import xdrlib \n')

import xdrlib # importa el modulo indicado

print ('empaquetar con la clase Packer del modulo xdrlib ; empaquetar = xdrlib.Packer \n')

empaquetar = xdrlib.Packer () # crea el empaquetador

print ('empaquetar una cadena de datos con la funcion pack_string del modulo xdrlib.Packer \n')

print ("empaquetar.pack_string (open('./Escritorio/ficheros5/BINARIO','rb').read()) \n")

empaquetar.pack_string (open('./Escritorio/ficheros5/BINARIO','rb').read()) # empaqueta los datos del fichero binario en formato cadena

print ('devolver el contenido empaquetado del buffer con la funcion get_buffer del modulo xdrlib.Packer \n')

print ('empaquetar.get_buffer () \n')

print (empaquetar.get_buffer (),'\n') # presenta el contenido del buffer -memoria intermedia- del empaquetado

print ('modulos propios python : modulo bz2 ; import bz2 \n')

import bz2 # importa el modulo indicado

print ("comprimir un fichero binario con la funcion BZ2File del modulo bz2 ; ComprimirBz2 =  bz2.BZ2File ('./Escritorio/ficheros5/ficheroBZ2.bz2','wb') \n")

ComprimirBz2 = bz2.BZ2File ('./Escritorio/ficheros5/ficheroBZ2.bz2','wb') # crea un objeto fichero en modo sobreescritura binario con compresion bzip2

print ("comprimir y escribir los datos ; ComprimirBz2.write (open('./Escritorio/ficheros5/BINARIO','rb').read()) \n")

ComprimirBz2.write (open('./Escritorio/ficheros5/BINARIO','rb').read()) # escribe el contenido devuelto por el fichero binario abierto y leido -comprime en bzip2 los datos-

print ("cerrar fichero ; ComprimirBz2.close () \n")

ComprimirBz2.close () # cierra el objeto fichero con compresion bzip2 

print ('modulos propios python : modulo gzip ; import gzip \n')

import gzip # importa el modulo indicado

print ("comprimir un fichero binario con la funcion GzipFile del modulo gzip ; ComprimirGzip =  gzip.GzipFile ('./Escritorio/ficheros5/ficheroGZIP.gz','wb') \n")

ComprimirGzip = gzip.GzipFile ('./Escritorio/ficheros5/ficheroGZIP.gz','wb') # crea un objeto fichero en modo sobreescritura binario con compresion gzip

print ("comprimir y escribir los datos ; ComprimirGzip.write (open('./Escritorio/ficheros5/BINARIO','rb').read()) \n")

ComprimirGzip.write (open('./Escritorio/ficheros5/BINARIO','rb').read()) # escribe el contenido devuelto por el fichero binario abierto y leido -comprime en gzip los datos-

print ("cerrar fichero ; ComprimirGzip.close () \n")

ComprimirGzip.close () # cierra el objeto fichero con compresion gzip 

print ('modulos propios python : modulo tarfile ; import tarfile \n')

import tarfile # importa el modulo indicado

print ('crear objeto tarfile con la funcion open del modulo tarfile ; empaquetarFicheros = tarfile.open ("./Escritorio/ficheros5/paqueteFICHEROS.tar","w") \n')

empaquetarFicheros = tarfile.open ("./Escritorio/ficheros5/paqueteFICHEROS.tar","w") # crea un objeto tar en modo escribir sin compresion -empaquetado tarfile-

print ("añadir fichero ; empaquetarFicheros.add ('./Escritorio/ficheros5/BINARIO') \n") 

empaquetarFicheros.add ('./Escritorio/ficheros5/BINARIO') # añade el fichero indicado

print ("cerrar fichero ; empaquetarFicheros.close () \n")

empaquetarFicheros.close () # cierra el fichero tarfile

print ('añadir ficheros al tarfile ; crear objeto tarfile en modo añadir con la funcion open del modulo tarfile : \n') 

print ('añadirFicherosEmpaquetador =  tarfile.open ("./Escritorio/ficheros5/paqueteFICHEROS.tar","a") \n')

añadirFicherosEmpaquetador =  tarfile.open ("./Escritorio/ficheros5/paqueteFICHEROS.tar","a") # crea un objeto tar en modo añadir sin compresion -empaquetado tarfile-

print ("añadir fichero ; añadirFicherosEmpaquetador.add ('./Escritorio/ficheros5/ficheroBASE64') \n") 

añadirFicherosEmpaquetador.add ('./Escritorio/ficheros5/ficheroBASE64') # añade el fichero indicado

print ("añadir fichero ; añadirFicherosEmpaquetador.add ('./Escritorio/ficheros5/ficheroASCII') \n") 

añadirFicherosEmpaquetador.add ('./Escritorio/ficheros5/ficheroASCII') # añade el fichero indicado

print ("añadir fichero ; añadirFicherosEmpaquetador.add ('./Escritorio/ficheros5/ficheroBZ2.bz2') \n") 

añadirFicherosEmpaquetador.add ('./Escritorio/ficheros5/ficheroBZ2.bz2') # añade el fichero indicado

print ("añadir fichero ; añadirFicherosEmpaquetador.add ('./Escritorio/ficheros5/ficheroGZIP.gz') \n") 

añadirFicherosEmpaquetador.add ('./Escritorio/ficheros5/ficheroGZIP.gz') # añade el fichero indicado

print ("cerrar fichero ; añadirFicherosEmpaquetador.close () \n")

añadirFicherosEmpaquetador.close () # cierra el fichero tarfile

print ('crear objeto tarfile en modo solo lectura ; ficheroTAR = tarfile.open ("./Escritorio/ficheros5/paqueteFICHEROS.tar","r") \n')

ficheroTAR = tarfile.open ("./Escritorio/ficheros5/paqueteFICHEROS.tar","r") # abre el fichero tarfile en modo solo lectura

print ('contenido del fichero tarfile con la funcion getmembers del modulo tarfile ; ficheroTAR.getmembers () \n')

for miembros in ficheroTAR.getmembers () : # iterador , bucle for in , pasa los elementos de la lista a miembros
	print (miembros,'\n') # presenta los miembros de la lista de los ficheros empaquetados en el fichero tarfile
else : # cuando finalice el iterador
	print ('FIN CONTENIDO FICHERO TAR \n') # presenta texto

print ('lista de nombres de los ficheros del tarfile ; ficheroTAR.list () \n')

ficheroTAR.list () # presenta una lista del fichero tarfile en formato ls -l en la salida stdout

print () # salto de linea

print ("cerrar fichero ; ficheroTAR.close () \n")

ficheroTAR.close () # cierra el fichero tarfile

print ('modulos propios python : modulo zipfile ; import zipfile \n')

import zipfile # importa el modulo indicado

print ('crear objeto fichero zipfile con la funcion ZipFile del modulo zipfile ; comprimirZip = zipfile.ZipFile ("./Escritorio/ficheros5/ficheroZip.zip","w") \n')

comprimirZip = zipfile.ZipFile ("./Escritorio/ficheros5/ficheroZip.zip","w") # crea objeto fichero con compresion zip 

print ("comprimir y escribir los datos ; comprimirZip.write ('./Escritorio/ficheros5/BINARIO') \n")

comprimirZip.write ('./Escritorio/ficheros5/BINARIO') # comprime y escribe el contenido del fichero indicado -comprime en zip los datos-

print ("cerrar fichero ; comprimirZip.close () \n")

comprimirZip.close () # cierra el fichero zip

print ('crear objeto fichero zipfile en modo añadir con la funcion ZipFile del modulo zipfile ; añadirZip = zipfile.ZipFile ("./Escritorio/ficheros5/ficheroZip.zip","a") \n')

añadirZip = zipfile.ZipFile ("./Escritorio/ficheros5/ficheroZip.zip","a") # crea objeto fichero con compresion zip -modo añadir-

print ("comprimir y escribir los datos ; añadirZip.write ('./Escritorio/ficheros5/ficheroBASE64') \n")

añadirZip.write ('./Escritorio/ficheros5/ficheroBASE64') # comprime y escribe el contenido del fichero indicado -comprime en zip los datos-

print ("comprimir y escribir los datos ; añadirZip.write ('./Escritorio/ficheros5/ficheroASCII') \n")

añadirZip.write ('./Escritorio/ficheros5/ficheroASCII') # comprime y escribe el contenido del fichero indicado -comprime en zip los datos-

print ("comprimir y escribir los datos ; añadirZip.write ('./Escritorio/ficheros5/ficheroBZ2.bz2') \n")

añadirZip.write ('./Escritorio/ficheros5/ficheroBZ2.bz2') # comprime y escribe el contenido del fichero indicado -comprime en zip los datos-

print ("comprimir y escribir los datos ; añadirZip.write ('./Escritorio/ficheros5/ficheroGZIP.gz') \n")

añadirZip.write ('./Escritorio/ficheros5/ficheroGZIP.gz') # comprime y escribe el contenido del fichero indicado -comprime en zip los datos-

print ("comprimir y escribir los datos ; añadirZip.write ('./Escritorio/ficheros5/paqueteFICHEROS.tar') \n")

añadirZip.write ('./Escritorio/ficheros5/paqueteFICHEROS.tar') # comprime y escribe el contenido del fichero indicado -comprime en zip los datos-

print ("cerrar fichero ; comprimirZip.close () \n")

añadirZip.close () # cierra el fichero zip

print ('crear objeto fichero zipfile en modo solo lectura con la funcion ZipFile del modulo zipfile ; lecturaZip = zipfile.ZipFile ("./Escritorio/ficheros5/ficheroZip.zip","r") \n')

lecturaZip = zipfile.ZipFile ("./Escritorio/ficheros5/ficheroZip.zip","r") # crea objeto fichero solo lectura 

print ('lista de nombres de archivos del fichero zip con la funcion namelist del modulo zipfile.ZipFile ; lecturaZip.namelist () \n')

for nombreFichero in lecturaZip.namelist () : # iterador , bucle for in , pasa los elementos de la lista a nombreFichero
	print (nombreFichero,'\n') # presenta el nombre del fichero del contenido del fichero zip 
else :  # cuando finalice el iterador
	print ('FIN CONTENIDO FICHERO ZIP \n') # presenta texto

print ("cerrar fichero ; lecturaZip.close () \n")

lecturaZip.close () # cierra el fichero zip

print ('modulos propios python : modulo aifc ; import aifc \n')

import aifc # importa el modulo indicado

print ('crear objeto fichero AIFF ; ficheroAIFF = aifc.open ("./Escritorio/ficheros5/audioAIFF.aiff","wb") \n')

ficheroAIFF = aifc.open ("./Escritorio/ficheros5/audioAIFF.aiff","wb") # crea objeto fichero AIFF

print ('numeros de canales del fichero de audio AIFF con la funcion setnchannels del modulo aifc : \n')

print ('ficheroAIFF.setnchannels (2) \n')

ficheroAIFF.setnchannels (2) # dos canales audio -estereo-

print ('tamaño sample audio con la funcion setsampwidth del modulo aifc : \n')

print ('ficheroAIFF.setsampwidth (2) \n')

ficheroAIFF.setsampwidth (2) # tamaño sample audio -2 bytes calidad cd-

print ('ratio frecuencia frames por segundo con la funcion setframerate del modulo aifc : \n')

print ('ficheroAIFF.setframerate (44100) \n')

ficheroAIFF.setframerate (44100) # ratio frecuencia frames por segundo

print ('escribir audio en el fichero del objeto con la funcion writeframes del modulo aifc : \n')

print ('ficheroAIFF.writeframes (open("./Escritorio/ficheros5/audio.mp3","rb").read()) \n')

ficheroAIFF.writeframes (open("./Escritorio/ficheros5/audio.mp3","rb").read()) # escribe el contenido del fichero indicado en el objeto fichero

print ('cerrar objeto fichero ; ficheroAIFF.close () \n')

ficheroAIFF.close () # cierra el fichero que enlaza el objeto fichero

print ('modulos propios python : modulo wave ; import wave \n')

import wave # importa el modulo indicado

print ('crear objeto fichero WAV ; ficheroWAV = wave.open ("./Escritorio/ficheros5/audioWAVE.wav","wb") \n')

ficheroWAV = wave.open ("./Escritorio/ficheros5/audioWAVE.wav","wb") # crea objeto fichero wav

print ('numeros de canales del fichero de audio wav con la funcion setnchannels del modulo wave : \n')

print ('ficheroWAV.setnchannels (2) \n')

ficheroWAV.setnchannels (2) # dos canales audio -estereo-

print ('tamaño sample audio con la funcion setsampwidth del modulo wave : \n')

print ('ficheroWAV.setsampwidth (2) \n')

ficheroWAV.setsampwidth (2) # tamaño sample audio -2 bytes calidad cd-

print ('ratio frecuencia frames por segundo con la funcion setframerate del modulo wave : \n')

print ('ficheroWAV.setframerate (44100) \n')

ficheroWAV.setframerate (44100) # ratio frecuencia frames por segundo

print ('escribir audio en el fichero del objeto con la funcion writeframesraw del modulo wave : \n')

print ('ficheroWAV.writeframes (open("./Escritorio/ficheros5/audio.mp3","rb").read()) \n')

ficheroWAV.writeframes (open("./Escritorio/ficheros5/audio.mp3","rb").read()) # escribe el contenido del fichero indicado en el objeto fichero

print ('cerrar objeto fichero ; ficheroWAV.close () \n')

ficheroWAV.close () # cierra el fichero que enlaza el objeto fichero

print ('modulos propios python : modulo audioop ; import audioop \n')

import audioop # importa el modulo indicado

print ('convertir un fragmento de audio estereo a mono con la funcion tomono del modulo audioop : \n')

print ('audioMONO = audioop.tomono (open("./Escritorio/ficheros5/audio.mp3","rb").read(),1,1,1) \n')

audioMONO = audioop.tomono (open("./Escritorio/ficheros5/audio.mp3","rb").read(),1,1,1) # convierte el audio del fichero indicado a mono desde el canal izquierdo

print ('guardar el audio en mono en un fichero : audioMono.mp3 \n')

with open("./Escritorio/ficheros5/audioMono.mp3","wb") as GRABAR : # abre , escribe y cierra el fichero -fichero enlazado al objeto fichero GRABAR-
	GRABAR.write (audioMONO) # escribe el contenido en el fichero que enlaza el objeto fichero
	
print ('modulos propios python : modulo sndhdr ; import sndhdr \n')

import sndhdr # importa el modulo indicado

print ('tipo de fichero de sonido con la funcion what del modulo sndhdr : \n')

print ('sndhdr.what ("./Escritorio/ficheros5/audioWAVE.wav") ',sndhdr.what ("./Escritorio/ficheros5/audioWAVE.wav"),'\n') # presenta una tupla con los valores del fichero de sonido

print ('modulos propios python : modulo configparser ; import configparser \n')

import configparser # importa el modulo indicado

print ('modulo para crear ficheros configuracion .ini de windows \n')

print ('modulos propios python : modulo csv ; import csv \n')

import csv # importa el modulo indicado

print ('leer fichero csv con la funcion reader del modulo csv \n')

with open("./Escritorio/ficheros5/ficheroCSV.csv","r") as CSV : # abre , lee y cierra el fichero -fichero enlazado al objeto fichero CSV-
	leerCSV = csv.reader (CSV) # lee el fichero que enlaza el objeto fichero
	for listaCSV in leerCSV : # iterador , bucle for in , pasa los elementos -listas- de la lista a listaCSV 
		print ('{0:25} {1:25} {2:25} \n'.format (listaCSV[0],listaCSV[1],listaCSV[2])) # presenta los elementos de la lista en una cadena formateada con un ancho minimo 
	else : # cuando finalice el iterador
		print ('FIN DEL CONTENIDO : ficheroCSV.csv \n') # presenta el texto

print ('modulos propios python : modulo os ; import os \n')

import os # importa el modulo indicado

print ('crear directorio con la funcion mkdir del modulo os ; os.mkdir ("./Escritorio/ficheros5/copiaFICHERO") \n')

try : # control de excepciones
	os.mkdir ("./Escritorio/ficheros5/copiaFICHERO") # crea el directorio indicado en la ruta -copiaFICHERO-
except FileExistsError : # tipo de excepcion
	print ('DIRECTORIO YA CREADO \n') # presenta el texto
	
print ('modulos propios python : modulo shutil ; import shutil \n')

import shutil # importa el modulo indicado

print ('copia un fichero con la funcion copy2 del modulo shutil :  \n')

print ('shutil.copy2 ("./Escritorio/ficheros5/paqueteFICHEROS.tar","./Escritorio/ficheros5/copiaFICHERO/paqueteFICHEROS.tar") ',shutil.copy2 ("./Escritorio/ficheros5/paqueteFICHEROS.tar","./Escritorio/ficheros5/copiaFICHERO/paqueteFICHEROS.tar"),'\n')

print ('modulos propios python : modulo tempfile ; import tempfile \n')

import tempfile # importa el modulo indicado

print ('crear un enlace a objeto fichero temporal con la funcion TemporaryFile del modulo tempfile ; ficheroTEMPORAL = tempfile.TemporaryFile () \n')

ficheroTEMPORAL = tempfile.TemporaryFile () # crea un objeto fichero temporal con las mismos atributos que un objeto fichero normal

print ('eliminar el fichero temporal con el atributo close ; ficheroTEMPORAL.close () \n')

ficheroTEMPORAL.close () # al cerrar el fichero se elimina el directorio y fichero temporal creados

print ('modulos propios python : modulo filecmp ; import filecmp \n')

import filecmp # importa el modulo indicado

print ('comparar dos ficheros con la funcion cmp del modulo filecmp : \n')

print ('filecmp.cmp ("./Escritorio/ficheros5/paqueteFICHEROS.tar","./Escritorio/ficheros5/copiaFICHERO/paqueteFICHEROS.tar") \n')

if filecmp.cmp ("./Escritorio/ficheros5/paqueteFICHEROS.tar","./Escritorio/ficheros5/copiaFICHERO/paqueteFICHEROS.tar") : # condicion , si son iguales -devuelve True-
	print ('los dos ficheros ; paqueteFICHEROS.tar son IGUALES \n') # presenta el texto
else : # si devuelve False 
	print ('los dos ficheros ; paqueteFICHEROS.tar NO son IGUALES \n') # presenta el texto

print ('modulos propios python : modulo multiprocessing ; import multiprocessing \n')

import multiprocessing # importa el modulo indicado

print ('crear las funcion a usar en multiprocessing ; proceso (*nombre) \n')

def info (titulo) : # definicion de la funcion
	print (titulo,'\n') # presenta el  argumento puesto
	print ('NOMBRE MODULO : ',__name__,'\n') # presenta el nombre del modulo que esta ejecutandose
	if hasattr (os,'getppid') : # si el atributo indicado pertenece al modulo ejecutado -devuelve True-
		print ('PROCESO PADRE : ',os.getppid (),'\n') # presenta el proceso padre que se esta ejecutando 
	print ('IDENTIFICADOR PROCESO :',os.getpid (),'\n') # presenta el identificador del proceso actual
	print ('--------------------------------------------------------------------------- \n') # presenta cadena
	
def proceso (*nombre) : # definicion de la funcion
	info ('funcion proceso') # llama y ejecuta la funcion con el argumento indicado
	for argumento in nombre : # iterador , bucle for in , pasa los elementos de la lista a argumento
		print ('HOLA : ',argumento,'\n') # presenta el texto y su valor
	else : # cuando finalice el iterador
		print ('FIN DE LOS ARGUMENTOS \n') # presenta el texto
	print ('*** FIN DEL PROCESO *** \n') # presenta el texto
	
print ('crear un proceso con la clase Process del modulo multiprocessing : \n')

print ('PROCESO = multiprocessing.Process (proceso,("PRIMERO","PENULTIMO","ULTIMO") \n')

info ('LINEA PRINCIPAL') # llama y ejecuta la funcion con el argumento indicado 

PROCESO = multiprocessing.Process (target=proceso,args=("PRIMERO","PENULTIMO","ULTIMO")) # instancia la clase Process -crea el proceso-

print ('ejecutar el proceso creado con la funcion start de Process ; PROCESO.start () \n')

print ('bloquear el proceso creado con la funcion join de Process ; PROCESO.join () \n')

PROCESO.start () # ejecuta el proceso creado 

PROCESO.join () # bloquea el proceso una vez se hayan terminado las llamadas 

print ('devolver el tamaño de un fichero indicado por una ruta con la funcion getsize del modulo path :  \n')

print ('os.path.getsize ("./Escritorio/ficheros5/paqueteFICHEROS.tar") ',os.path.getsize ("./Escritorio/ficheros5/paqueteFICHEROS.tar"),'\n')

print ('modulos propios python : modulo mimetypes ; import mimetypes \n') # presenta el tamaño del fichero indicado en la ruta

import mimetypes # importa el modulo indicado

print ('devolver el tipo de archivo del indicado con la funcion guess_type del modulo mimetypes : \n')

print ('mimetypes.guess_type ("./Escritorio/ficheros5/paqueteFICHEROS.tar") ',mimetypes.guess_type ("./Escritorio/ficheros5/paqueteFICHEROS.tar"),'\n') # presenta el tipo de fichero del indicado

print ('modulos propios python : modulo socket ; import socket \n') # presenta el tamaño del fichero indicado en la ruta

import socket # importa el modulo indicado

print ('devolver informacion sobre una direccion de red con la funcion getaddrinfo del modulo socket : \n')

print ('socket.getaddrinfo ("google.com",80,proto=socket.IPPROTO_TCP) \n\n')

print (socket.getaddrinfo ("google.com",80,proto=socket.IPPROTO_TCP),'\n') # presenta informacion sobre el protocolo TCP de una direccion de red 

print ('modulos propios python : modulo ssl ; import ssl \n') # presenta el tamaño del fichero indicado en la ruta

import ssl # importa el modulo indicado

print ('devolver la version de la libreria ssl cargada con la funcion OPENSSL_VERSION del modulo ssl ; ssl.OPENSSL_VERSION ',ssl.OPENSSL_VERSION,'\n') # presenta la version cargada de la libreria

print ('devolver lista de soporte de TLS con la funcion CHANNEL_BINDING_TYPES del modulo ssl ; ssl.CHANNEL_BINDING_TYPES ',ssl.CHANNEL_BINDING_TYPES,'\n')

print ('modulos propios python : modulo socketserver ; import socketserver \n') # presenta el tamaño del fichero indicado en la ruta

import socketserver # importa el modulo indicado

print ('crear clase miCabeceraTCP ; class miCabeceraTCP (socketserver.BaseRequestHandler) \n')

class miCabeceraTCP (socketserver.BaseRequestHandler) : # definicion de la clase -hereda de la clase BaseRequestHandler-
	def handle (self) : # definicion del atributo
		self.data = self.request.recv (1024).strip () # recibe bloques de 1024 bytes
		print ('{} escribio : '.format (self.client_address [0])) # presenta la cadena formateada y su valor -direccion cliente-
		print (self.data) # presenta el bloque recibido de 1024 bytes
		self.request.sendall (self.data.upper()) # reenvio del bloque de datos en mayusculas -1024 bytes-

SERVIDOR,PUERTO = 'localhost',9999 # asignacion multiple -SERVIDOR = 'localhost' , PUERTO = 9999-

print ('crear un servidor TCP con la funcion TCPServer del modulo socketserver : \n')

print ('Servidor = socketserver.TCPServer ((SERVIDOR,PUERTO),miCabeceraTCP) \n')

Servidor = socketserver.TCPServer ((SERVIDOR,PUERTO),miCabeceraTCP) # crea el servidor TCP en el puerto y host indicado 

print ('ejecutar el servidor en bucle continuo con la funcion serve_forever del modulo socketserver ; Servidor.serve_forever () \n')

# Servidor.serve_forever () # ejecuta el servidor de forma continua -quitar almohadilla para ejecutar-

print ('detener el servidor con la funcion shutdown del modulo socketserver ; Servidor.shutdown () \n')

# Servidor.shutdown () # detiene el servidor TCP -quitar almohadilla para ejecutar-

print ('modulos propios python : modulo asyncore ; import asyncore \n') # presenta el tamaño del fichero indicado en la ruta

import asyncore # importa el modulo indicado

print ('crear clase clienteHTTP ; class clienteHTTP (asyncore.dispatcher) \n')

class clienteHTTP (asyncore.dispatcher) : # definicion de la clase -hereda de la clase dispatcher-
	def __init__ (self,servidor,ruta) : # definicion del metodo , inicializa la clase con los argumentos indicados
		asyncore.dispatcher.__init__ (self) # inicializa el metodo __init__ de dispatcher
		self.create_socket () # crea el socket
		self.connect ((servidor,80)) # conecta con el servidor y puerto indicados
		self.buffer = bytes ('GET %s HTTP/1.0\r\nHost : %s\r\n\r\n' % (ruta,servidor),'ascii') # carga en memoria intermedia -buffer- la cabecera del servidor indicado
		
	def handle_connect (self) : # definicion del atributo heredado
		pass # funcion de relleno -no hace nada-
	
	def handle_close (self) : # definicion del atributo heredado
		self.close () # cierra la conexion con el host indicado
		
	def handle_read (self) : # definicion del atributo heredado
		print (self.recv (20000)) # presenta el bloque de bytes indicados recibidos -20000 bytes-
		
	def writable (self) : # definicion del atributo heredado
		return (len (self.buffer) > 0) # si el buffer no esta vacio , devuelve el contenido
	
	def handle_write (self) : # definicion del atributo heredado
		enviar = self.send (self.buffer) # envia el contenido recibido en la memoria -buffer-
		self.buffer = self.buffer [enviar : ] # asigna el contenido de la memoria -desde la posicion indicada hasta el final , subcadena- 

print ('instanciar cliente ; CLIENTE_HTTP = clienteHTTP ("www.python.org","/") \n')

CLIENTE_HTTP = clienteHTTP ("www.python.org","/") # instancia la clase con el host y ruta indicados 

print ('iniciar el cliente con la funcion loop del modulo asyncore ; asyncore.loop () \n')

asyncore.loop () # inicia el cliente con los argumentos indicados en la instancia

print ('modulos propios python : modulo asynchat ; import asynchat \n') # presenta el tamaño del fichero indicado en la ruta

import asynchat # importa el modulo indicado

print ('crear clase solicitudCabecerasHTTP ; class solicitudCabecerasHTTP (asynchat.async_chat) \n')

class solicitudCabecerasHTTP (asynchat.async_chat) : # definicion de la clase -hereda de la clase async_chat-
	def __init__ (self,sock,addr,sessions,log) : # definicion del metodo , inicializa la clase con los argumentos indicados
		asynchat.async_chat.__init__ (self,sock=sock) #  inicializa el metodo __init__ de async_chat asignando el valor de sock al suyo propio
		self.addr = addr # asigna el valor a self.addr
		self.sessions = sessions # asigna el valor a self.sessions
		self.ibuffer = [] # asigna una lista vacia donde añadir los datos de entrada al buffer 
		self.obuffer = b"" # asigna una cadena binaria vacia donde añadir los datos de entrada como salida binaria
		self.set_terminator (b"\r\n\r\n") # añade el valor de terminacion de la cadena binaria
		self.reading_headers = True # puede leer las cabeceras 
		self.handling = False # manejo de cabeceras
		self.cgi_data = None # ningun dato de cgi 
		self.log = log # asigna el valor a self.log
		
	def collect_incoming_data (self,data) : # definicion del atributo heredado
		self.ibuffer.append (data) # añade los datos a la lista de entrada del buffer
		
	def found_terminator (self) : # definicion del atributo heredado
		if self.reading_headers : # condicion , si el valor es True
			self.reading_headers = False # cambia el valor a False
			self.parse_headers (b"".join (self.ibuffer)) # join , une los datos de la lista de entrada al buffer en una sola cadena binaria separados por espacios en blanco , analiza la cadena
			self.ibuffer = [] # se vacia la lista de entrada de datos -asigna lista vacia-
			if self.op.upper == b"POST" : # condicion , si el valor devuelto por el operador es la cadena
				clen = self.headers.getheader ("content-length") # asigna la cabecera indicada en la cadena
				self.set_terminator (int (clen)) #  añade el valor de terminacion
			else : # si no coincide con el operador -POST-
				self.handling = True  # maneja las cabeceras
				self.set_terminator (None) #  vacia el valor de terminacion
				self.handle_request () # maneja las cabeceras
		elif not self.handling : # condicion , si es False 
			self.set_terminator (None) #  vacia el valor de terminacion
			self.cgi_data = parse (self.headers,b"".join(self.ibuffer)) # llama al fichero cgi indicado para analizar la cadena generada con join y la lista de datos de entrada
			self.handling = True # cambia el valor a True
			self.ibuffer = [] # se vacia la lista de entrada de datos -asigna lista vacia-
			self.handle_request () # maneja las cabeceras 

print ('instanciar la clase solicitudCabecerasHTTP ; solicitud_cabeceras = solicitudCabecerasHTTP (None,"www.python.org",None,None) \n')

solicitud_cabeceras = solicitudCabecerasHTTP (None,"www.python.org",None,None) # instancia la clase con los argumentos indicados 

print ('escribir en las entradas y salidas estandard con la funcion fifo del modulo asynchat :  \n')

print ('EntradaSalida = asynchat.fifo ([1,2,3,4,5,6,7,8,"penultimo","ultimo"]) \n')

EntradaSalida = asynchat.fifo ([1,2,3,4,5,6,7,8,"penultimo","ultimo"]) # escribir los datos en las entradas y salidas estandard -buffer-

print ('comprobar si el fifo esta lleno o vacio con la funcion is_empty del modulo asynchat ; EntradaSalida.is_empty () \n')

if EntradaSalida.is_empty () : # condicion , si devuelve True
	print ('el buffer de fifo esta VACIO \n') # presenta el texto
else : # si es False
	print ('el buffer de fifo NO esta VACIO \n') # presenta el texto

print ('devolver el primer elemento fifo procesado con la funcion first del modulo asynchat ; EntradaSalida.first () ',EntradaSalida.first (),'\n')

print ('modulos propios python : paquete wsgiref ; import wsgiref \n') # presenta el tamaño del fichero indicado en la ruta

import wsgiref # importa el paquete indicado

print ('importar el modulo simple_server ; import wsgiref.simple_server \n')

import wsgiref.simple_server # importa el modulo indicado

print ('crear un servidor simple HTTP usando la funcion make_server de la clase simple_server \n')

print ('servidorHTTP = wsgiref.simple_server.make_server ("",8000,wsgiref.simple_server.demo_app) \n')

servidorHTTP = wsgiref.simple_server.make_server ("",8000,wsgiref.simple_server.demo_app) # crea un servidor HTTP con la configuracion estandard de demo_app

print ('ejecutar el servidor una vez con la funcion handle_request del modulo wsgiref ; servidorHTTP.handle_request () \n')

#servidorHTTP.handle_request () # enviar una peticion al servidor y salir , quitar almohadilla para ejecutar

print ('modulos propios python : modulo server ; import http.server \n') # presenta el tamaño del fichero indicado en la ruta

import http.server # importa el paquete indicado

print ('añadir directorio CGI ; http.server.CGIHTTPRequestHandler.cgi_directories += ["./Escritorio/ficheros5"] \n')

http.server.CGIHTTPRequestHandler.cgi_directories += ["./Escritorio/ficheros5"] # añade el directorio contenido ficheros CGI

print ('manipular CGI con la funcion CGIHTTPRequestHandler del modulo http.server : \n')

print ('manipularCGI = http.server.HTTPServer (("127.0.0.1",8001),http.server.CGIHTTPRequestHandler) \n')

manipularCGI = http.server.HTTPServer (("127.0.0.1",8001),http.server.CGIHTTPRequestHandler) # crea el servidor HTTP con ejecucion de ficheros CGI en el directorio ; ./Escritorio/ficheros5

print ('ejecutar el servidor con manipulacion de CGI ; manipularCGI.handle_request () \n')

#manipularCGI.handle_request () # enviar una peticion al servidor y salir , quitar almohadilla para ejecutar

print ('modulos propios python : modulo cookies ; import http.cookies \n') # presenta el tamaño del fichero indicado en la ruta

import http.cookies # importa el paquete indicado

print ('crear una cookie con la funcion SimpleCookie del modulo cookies ; cookie = http.cookies.SimpleCookie () \n')

cookie = http.cookies.SimpleCookie () # crea una cookie

print ('añadir contenido a la cookie ; cookie ["USUARIO"] = "MOZILLA" \n')

cookie ["USUARIO"] = "MOZILLA" # añadir contenido a la cookie

print ('añadir contenido a la cookie ; cookie ["tipo"] = "64 BIT" \n')

cookie ["tipo"] = "64 BIT" # añadir contenido a la cookie

print ('generar cabeceras HTTP llamando a la cookie ; cookie  \n\n',cookie,'\n') # presenta el contenido generado para la cookie

print ('devolver el contenido de la cookie en una cadena con la funcion output del modulo cookies ; cookie.output () \n')

print (cookie.output (),'\n') # presenta el cotenido de la cookie en formato cadena

print ('modulos propios python : modulo cookiejar ; import http.cookiejar \n') # presenta el tamaño del fichero indicado en la ruta

import http.cookiejar # importa el paquete indicado

print ('crear una cookiejar con la funcion CookieJar del modulo cookiejar ; cookieJAR = http.cookiejar.CookieJar () \n')

cookieJAR = http.cookiejar.CookieJar () # crea una cookiejar

print ('eliminar todas las cookiejar con la funcion clear del modulo cookiejar : \n')

print ('cookieJAR.clear () \n')

cookieJAR.clear () # elimina todas las cookiejar

print ('modulos propios python : modulo cgi ; import cgi \n') # presenta el tamaño del fichero indicado en la ruta

import cgi # importa el paquete indicado

print ('leer datos desde un CGI con la clase FieldStorage del modulo cgi ; forma = cgi.FieldStorage () \n')

forma = cgi.FieldStorage () # crea el interface de lectura

print ('devolver un valor asociado con el campo del nombre con la funcion getfirst de la clase FieldStorage : \n')

print ('forma.getfirst ("usuario","").upper () ',forma.getfirst ("usuario","").upper (),'\n')

cabecerasHTTP = 'HTTP/1.1 500 Domain Not Found\r\nServer: Varnish\r\nRetry-After: 0\r\ncontent-type: text/html\r\nCache-Control: private, no-cache\r\nconnection: keep-alive\r\nContent-Length: 77\r\nAccept-Ranges: bytes\r\nDate: Fri, 26 Jun 2015 20:18:50 GMT\r\nVia: 1.1 varnish\r\nConnection: close\r\n\r\n\n<html>\n<head>\n<title> </title>\n</head>\n<body>\nunknown domain: </body></html>'

print ('analizar cadena cabecera y devolver el MIMETYPE con la funcion parse_header del modulo cgi ; cgi.parse_header (cabecerasHTTP) \n')

print (cgi.parse_header (cabecerasHTTP),'\n') # analiza la cadena e intenta devolver el tipo  de MIMETYPE  

print ('modulos propios python : modulo cgitb ; import cgitb \n') # presenta el tamaño del fichero indicado en la ruta

import cgitb # importa el paquete indicado

print ('activar las excepciones provocadas por ficheros CGI con la funcion enable del modulo cgitb : \n')

print ('cgitb.enable (logdir="./Escritorio/ficheros5") \n')

cgitb.enable (logdir="./Escritorio/ficheros5") # activa la opcion de salvar las excepciones provocadas por ficheros CGI en la ruta indicada

print ('modulos propios python : modulo client ; import http.client \n') # presenta el tamaño del fichero indicado en la ruta

import http.client # importa el paquete indicado

print ('conexion con un servidor http con el cliente predefinido con la funcion HTTPConnection del modulo http.client : \n')

print ('clienteHttp = http.client.HTTPConnection ("www.python.org") \n')

clienteHttp = http.client.HTTPConnection ("www.python.org") # crea el cliente con el servidor a conectar

print ('conectar con el servidor con la funcion connect de HTTPConnection ; clienteHttp.connect () \n')

clienteHttp.connect () # conecta con el servidor que enlaza el objeto del cliente

print ('desconectar con el servidor con la funcion close de HTTPConnection ; clienteHttp.close () \n')

clienteHttp.close () # desconecta con el servidor que enlaza el objeto del cliente

print ('modulos propios python : modulo parse ; import urllib.parse \n') # presenta el tamaño del fichero indicado en la ruta

import urllib.parse # importa el paquete indicado

print ('analizar la url con la funcion urlparse de urllib.parse : \n')

print ('analizarURL = urllib.parse.urlparse ("http://www.python.org/index.html") \n')

analizarURL = urllib.parse.urlparse ("http://www.python.org/index.html") # analiza el contenido del url indicado

print ('devolver protocolo del url con el atributo scheme de urlparse ; analizarURL.scheme ; ',analizarURL.scheme,'\n')

print ('devolver puerto del url con el atributo port de urlparse ; analizarURL.port ; ',analizarURL.port,'\n')

print ('devolver url con el funcion geturl de urlparse ; analizarURL.geturl () ; ',analizarURL.geturl (),'\n')

print ('modulos propios python : modulo request ; import urllib.request \n') # presenta el tamaño del fichero indicado en la ruta

import urllib.request # importa el paquete indicado

print ('crear objeto fichero url con la funcion urlopen de urllib.request : \n')

print ('ficheroURL = urllib.request.urlopen ("http://www.python.org/") \n')

ficheroURL = urllib.request.urlopen ("http://www.python.org/") # crea el objeto fichero de la url indicada -fichero html-

print ('leer el contenido y devolverlo en una sola cadena en formato utf-8 con el metodo read ; ficheroURL.read ().decode ("utf8","ignore") \n')

print (ficheroURL.read ().decode ("utf8","ignore"),'\n') # presenta el contenido del objeto fichero en una sola cadena en formato utf-8 -decode ("utf8","ignore")-

print ('cerrar objeto fichero ficheroURL con el metodo close ; ficheroURL.close () \n')

ficheroURL.close () # cierra el objeto fichero

print ('modulos propios python : modulo error ; import urllib.error \n') # presenta el tamaño del fichero indicado en la ruta

import urllib.error # importa el paquete indicado

print ('controlar una excepcion del paquete urllib con la excepcion URLError de urllib.error ; urllib.error.URLError \n')

if urllib.error.URLError : # condicion , si devuelve True -contiene una excepcion-
	print ('--- SE HA PRODUCIDO UNA EXCEPCION ---\n') # presenta la cadena
	print ('NOMBRE : ',urllib.error.URLError.__name__,'\n') # presenta nombre de la clase de excepcion 
else : # si devuelve False
	pass # funcion de relleno . no hace nada

print ('modulos propios python : modulo robotparser ; import urllib.robotparser \n') # presenta el tamaño del fichero indicado en la ruta

import urllib.robotparser # importa el paquete indicado

print ('crear analizador robots.txt con la clase RobotFileParser de urllib.robotparser ; analizarROBOT = urllib.robotparser.RobotFileParser () \n')

analizarROBOT = urllib.robotparser.RobotFileParser () # crea una instancia del analizador de robots.txt

print ('indicar URL de los robots a analizar con el metodo set_url de RobotFileParser ; analizarROBOT.set_url ("http://www.python.org/") \n')

analizarROBOT.set_url ("http://www.python.org/") # añade la url del robots a analizar

print ('leer y analizar la url y cabeceras de los robots.txt con el metodo read de RobotFileParser ; analizarROBOT.read () \n')

analizarROBOT.read () # lee y analiza robots.txt de la url indicada

print ('modulos propios python : modulo json ; import json \n') # presenta el tamaño del fichero indicado en la ruta

import json # importa el paquete indicado

print ('serializar valores en formato cadena con el metodo dumps de json : \n')

print ('serializarFormatoString = json.dumps (["lista",{"diccionario" : ("tupla",1021,.03)}]) \n')

serializarFormatoString = json.dumps (["lista",{"diccionario" : ("tupla",1021,.03)}]) # serializa la lista en formato cadena

print ('contenido serializarFormatoString ',serializarFormatoString,'\n') # presenta el contenido de los datos serializados en una cadena 

print ('modulos propios python : modulo xmlrpc.client ; import xmlrpc.client \n') # presenta el tamaño del fichero indicado en la ruta

import xmlrpc.client # importa el paquete indicado

print ('iniciar cliente con ServerProxy de xmlrpc.client ; clientePROXY = xmlrpc.client.ServerProxy("http://localhost:8000/") \n')

clientePROXY = xmlrpc.client.ServerProxy("http://localhost:8000/") # inicia el cliente en el puerto indicado del sistema local 

print ('cliente iniciado >>>> ',clientePROXY,'\n') # presenta los datos recibidos en el puerto indicado del sistema local

print ('modulos propios python : modulo xmlrpc.server ; import xmlrpc.server \n') # presenta el tamaño del fichero indicado en la ruta

import xmlrpc.server # importa el paquete indicado

print ('restingir el servidor a una ruta propia con la clase propia ; class manejadorSOLICITUD (xmlrpc.server.SimpleXMLRPCRequestHandler) \n')

class manejadorSOLICITUD (xmlrpc.server.SimpleXMLRPCRequestHandler) : # definicion de la clase , hereda de la clase padre ; SimpleXMLRPCRequestHandler
	rpc_paths = ("./Escritorio/ficheros5",) # ruta especifica para el servidor

print ('crear servidor con SimpleXMLRPCServer de xmlrpc.server ; servidorXMLRPC = xmlrpc.server.SimpleXMLRPCServer (("localhost",8002),requestHandler=manejadorSOLICITUD) \n')

servidorXMLRPC = xmlrpc.server.SimpleXMLRPCServer (("localhost",8002),requestHandler=manejadorSOLICITUD) # crea el servidor xmlrpc en el puerto indicado del sistema local 

print ('recargar los metodos de system con register_introspection_functions ; servidorXMLRPC.register_introspection_functions () \n')

servidorXMLRPC.register_introspection_functions () # carga los metodos de system

print ('registrar una funcion en el servidor con register_function de xmlrpc.server ; servidorXMLRPC.register_function (pow) \n')

servidorXMLRPC.register_function (pow) # registra la funcion indicada en el servidor que responde a las peticiones xmlrpc

print ('iniciar servidor xmlrpc con serve_forever de xmlrpc.server ; servidorXMLRPC.serve_forever () \n')

#servidorXMLRPC.serve_forever () # inicia el servidor que enlaza el objeto en el puerto indicado del sistema local -quitar almohadilla para iniciar-

print ('modulos propios python : modulo ftplib ; import ftplib \n') # presenta el tamaño del fichero indicado en la ruta

import ftplib # importa el paquete indicado

print ('conectar con el url del servidor ftp con FTP de ftplib ; FTP = ftplib.FTP ("ftp.debian.org") \n') 

FTP = ftplib.FTP ("ftp.debian.org") # conecta con el host del url indicado

print ('entrar al servidor ftp con login de ftplib ; FTP.login () \n')

print (FTP.login (),'\n') # entrar al servidor ftp con usuario y password ; anonymous -presenta codigo conexion-

print ('cambiar al directorio de uso con cwd de ftplib ; FTP.cwd ("debian") \n')

FTP.cwd ("debian") # cambia al directorio indicado del servidor ftp 

print ('ejecutar un comando con retrlines de ftplib ; FTP.retrlines ("LIST") \n')

FTP.retrlines ("LIST") # listar el contenido del directorio actual del servidor ftp -debian-

print ()

print ('desconectar del servidor ftp con quit de ftplib ; FTP.quit () \n')

print (FTP.quit (),'\n') # desconecta del servidor ftp 

print ('modulos propios python : modulo nntplib ; import nntplib \n') # presenta el tamaño del fichero indicado en la ruta

import nntplib # importa el paquete indicado

print ('conectar con servidor de noticias con NNTP de nntplib ; servidorNOTICIAS = nntplib.NNTP ("news.gmane.org") \n')

servidorNOTICIAS = nntplib.NNTP ("news.gmane.org") # conecta con la url del servidor de noticias indicado

print ('aaceder a un grupo de noticias con group de nntplib ; servidorNOTICIAS.group ("gmane.comp.python.committers") \n')

respuesta,numeroMensajes,primero,ultimo,nombre = servidorNOTICIAS.group ("gmane.comp.python.committers") # desempaqueta la salida de group en las variables indicadas

print ('GRUPO : {0} CON {1} ARTICULOS - RANGO : {2} A {3} \n'.format (nombre,numeroMensajes,primero,ultimo)) # presenta cadena formateada con sus valores

print ('seleccionar el numero de mensajes con over de nntplib ; servidorNOTICIAS.over ((ultimo - 9,ultimo)) \n')

Respuesta,descripciones = servidorNOTICIAS.over ((ultimo - 9,ultimo)) # selecciona los mensajes de noticias por su numero , inicio a ultimo -desempaqueta la salida-

for identificador,descripcion in descripciones : # iterador , bucle for in , pasa los elementos a identificador -numero identificador- , descripcion -texto descripcion mensaje-
	print ('NUMERO MENSAJE : {0} TOPIC : {1} \n'.format (identificador,nntplib.decode_header(descripcion ["subject"]))) # presenta cadena formateada con sus valores 

print ('cerrar conexion con el servidor de noticias con quit de nntplib ; servidorNOTICIAS.quit () \n')

print (servidorNOTICIAS.quit (),'\n') # cierra la conexion con el servidor de noticias -presenta codigo de desconexion-

print ('modulos propios python : modulo telnetlib ; import telnetlib \n') # presenta el tamaño del fichero indicado en la ruta

import telnetlib # importa el paquete indicado

print ('crear servidor telnet con Telnet de telnetlib ; servidorTELNET = telnetlib.Telnet () \n')

servidorTELNET = telnetlib.Telnet () # crea el servidor telnet        

print ('conectar con el servidor telnet con el metodo open de Telnet de telnetlib ; servidorTELNET.open ("localhost",23) \n') 

try : # control de excepciones
	servidorTELNET.open ("localhost",23) # conecta con el servidor telnet en el sistema local y puerto estandard
except ConnectionRefusedError as Error : # tipo de excepcion
	print ('*** ERROR , conexion RECHAZADA - {0} \n'.format (Error)) # presenta la cadena formateada con su valor -salida excepcion-
	
print ('cerrar conexion servidor telnet con el metodo close de Telnet de telnetlib ; servidorTELNET.close () \n')

servidorTELNET.close () # cierra la conexion con el servidor telnet

print ('modulos propios python : modulo smtpd ; import smtpd \n') # presenta el tamaño del fichero indicado en la ruta

import smtpd # importa el paquete indicado

print ('crear servidor smtp personalizado de SMTPServer del modulo smtpd ; class servidorSMTPpersonalizado (smtpd.SMTPServer) \n')

class servidorSMTPpersonalizado (smtpd.SMTPServer) : # definicion de la clase -hereda de la clase padre smtpd.SMTPServer-
	def procesarMensaje (self,peer,mailfrom,rcpttos,data) : # definicion del metodo
		print ('RECIVIDO mensaje DESDE {0} \n'.format (peer)) # presenta la cadena formateada y  su valor -nombre emisor correo-
		print ('MENSAJE direccionado DESDE {0} \n'.format (mailfrom)) # presenta la cadena formateada y  su valor -direccion del emisor del correo-
		print ('MENSAJE direccionado A {0} \n'.format (rcpttos)) # presenta la cadena formateada y  su valor -direccion del receptor del correo-
		print ('LONGITUD MENSAJE {0} \n'.format (len(data))) # presenta la longitud del mensaje en numero de caracteres

print ('instanciar servidor personalizado ; servidorCORREO = servidorSMTPpersonalizado (("127.0.0.1",1025),None) \n')

servidorCORREO = servidorSMTPpersonalizado (("127.0.0.1",1025),None) # instancia el servidor personalizado en la direccion IP -loop sistema- y puerto indicado

print ('iniciar de modo asincronico el servidor personalizado ; asyncore.loop () \n')

#asyncore.loop () # inicia el servidor en modo asincronico en bucle -quitar almohadilla para iniciar-

print ('modulos propios python : modulo smtplib ; import smtplib \n') # presenta el tamaño del fichero indicado en la ruta

import smtplib # importa el paquete indicado

print ('iniciar cliente smtp con SMTP de smtplib ; clienteSMTP = smtplib.SMTP () \n')

clienteSMTP = smtplib.SMTP () # inicia el cliente smtp

print ('conectar el cliente al host con el metodo connect de SMTP ; clienteSMTP.connect ("localhost",25) \n') 

try : # control de excepciones
	clienteSMTP.connect ("localhost",25) # conecta al host y puerto indicado
except ConnectionRefusedError as Error : # tipo de excepcion
	print ('*** ERROR , conexion RECHAZADA - {0} \n'.format (Error)) # presenta la cadena formateada con su valor -salida excepcion-

print ('cerrar conexion cliente smtp con el metodo quit de SMTP ; clienteSMTP.quit () \n')

try : # control de excepciones
	clienteSMTP.quit () # cierra la conexion del cliente smtp
except smtplib.SMTPServerDisconnected : # tipo de excepcion
	print ('*** ERROR , CLIENTE NO CONECTADO \n') # presenta la cadena 

print ('modulos propios python : modulo imaplib ; import imaplib \n') # presenta el tamaño del fichero indicado en la ruta

import imaplib # importa el paquete indicado

print ('iniciar cliente imap con IMAP4 de imaplib ; clienteIMAP = imaplib.IMAP4 ("localhost",143) \n')

try : # control de excepciones
	clienteIMAP = imaplib.IMAP4 ("localhost",143) # inicia el cliente imap con el host y puerto indicado
except ConnectionRefusedError as Error : # tipo de excepcion
	print ('*** ERROR , conexion RECHAZADA - {0} \n'.format (Error)) # presenta la cadena formateada con su valor -salida excepcion-

print ('conectar el cliente al host y puerto pòr defecto con el metodo open de IMAP4 ; clienteIMAP.open () \n') 

try : # control de excepciones
	clienteIMAP.open () # conecta  al servidor -localhost,143-
except : # tipo de excepcion
	print ('NO CONECTADO AL SERVIDOR \n') # presenta la cadena  

print ('desconectar del servidor de correo con el metodo logout de IMAP4 ; clienteIMAP.logout () \n')

try : # control de excepciones
	clienteIMAP.logout () # desconecta el cliente del servidor
except : # tipo de excepcion
	print ('NO CONECTADO AL SERVIDOR \n') # presenta la cadena  

print ('modulos propios python : modulo poplib ; import poplib \n') # presenta el tamaño del fichero indicado en la ruta

import poplib # importa el paquete indicado

print ('iniciar el cliente pop3 con POP3 de poplib ; clientePOP3 = poplib.POP3 ("localhost") \n')

try : # control de excepciones
	clientePOP3 = poplib.POP3 ("localhost") # iniciar el cliente pop3 en el host indicado con el puerto por defecto -110-
except ConnectionRefusedError as Error : # tipo de excepcion
	print ('*** ERROR , conexion RECHAZADA - {0} \n'.format (Error)) # presenta la cadena formateada con su valor -salida excepcion-

print ('cerrar conexion del cliente pop3 con el servidor con el metodo quit de POP3 ; clientePOP3.quit () \n')

try : # control de excepciones
	clientePOP3.quit () # cierra la conexion del  servidor POP3
except : # tipo de excepcion
	print ('NO CONECTADO AL SERVIDOR \n') # presenta la cadena  

print ('modulos propios python : modulo mailbox ; import mailbox \n') # presenta el tamaño del fichero indicado en la ruta

import mailbox # importa el paquete indicado

print ('cambiar el directorio de trabajo ; os.chdir ("./Escritorio/ficheros5") \n')

os.chdir ("./Escritorio/ficheros5") # cambia el directorio de trabajo al indicado

print ('crear interfaz correo con Maildir de mailbox ; interfazBuzonCorreo = mailbox.Maildir ("BUZONCORREO") \n')

interfazBuzonCorreo = mailbox.Maildir ("BUZONCORREO") # crea el interfaz de buzon de correo

print ('devolver lista de directorios con el metodo list_folders de Maildir ; interfazBuzonCorreo.list_folders () \n')

print (interfazBuzonCorreo.list_folders (),'\n') # presenta una lista con los directorios del directorio principal

print ('añadir directorio con el metodo add_folder de Maildir ; interfazBuzonCorreo.add_folder ("buzonCorreo") \n')

interfazBuzonCorreo.add_folder ("buzonCorreo") # añade el directorio al directorio principal

print ('devolver lista de directorios con el metodo list_folders de Maildir ; interfazBuzonCorreo.list_folders () \n')

print (interfazBuzonCorreo.list_folders (),'\n') # presenta una lista con los directorios del directorio principal

print ('aplicar todos los cambios con el metodo flush de Maildir ; interfazBuzonCorreo.flush () \n')

interfazBuzonCorreo.flush () # aplica todos los cambios indicados

print ('volver al directorio de trabajo principal ; os.chdir ("/home/josevicente") \n')

os.chdir ("/home/josevicente") # cambia el directorio de trabajo al indicado

print ('modulos propios python : modulo email ; import email \n') # presenta el tamaño del fichero indicado en la ruta

import email # importa el paquete indicado

print ('importar el modulo image del paquete email.mime ; import email.mime.image \n')

import email.mime.image # importa el modulo indicado del paquete

print ('crear el contenido de un email para enviar una imagen con mime.image.MIMEImage de email : mensajeImagen = email.mime.image.MIMEImage (objetoFichero.read ()) \n')

with open ('./Escritorio/ficheros5/BINARIO','rb') as objetoFichero : # abre y cierra el fichero en modo solo lectura binaria
	mensajeImagen = email.mime.image.MIMEImage (objetoFichero.read ()) # buscar el tipo de imagen específica
	

print ("mensajeImagen ['Subjet'] = 'envio imagen' \n")

mensajeImagen ['Subjet'] = 'envio imagen' # titulo del mensaje

print ("mensajeImagen ['From'] = 'yo@yo.com' \n")

mensajeImagen ['From'] = 'yo@yo.com' # direccion de correo saliente

print ("mensajeImagen ['To'] = 'tu@tu.com' \n")

mensajeImagen ['To'] = 'tu@tu.com' # direccion de correo receptor

print ('enviar mensaje de email al servidor de correo smtp ; servidorSMTP = smtplib.SMTP ("localhost") \n')

#servidorSMTP = smtplib.SMTP ("localhost") # crea el servidor de envio -quitar almohadilla , descomentar-

print ('enviar el mensaje ; servidorSMTP.send_message (mensajeImagen) \n')

#servidorSMTP.send_message (mensajeImagen) # envia el mensaje creado en el formato indicado -imagen- -quitar almohadilla , descomentar-

print ('desconectar del servidor smtp ; servidorSMTP.quit () \n')

#servidorSMTP.quit () # cierra la conexion con el servidor SMTP -quitar almohadilla , descomentar-

print ('modulos propios python : modulo xml.dom ; import xml.dom \n') # presenta el tamaño del fichero indicado en la ruta

import xml.dom # importa el paquete indicado

print ('devolver una implementacion DOM adecuada con getDOMImplementation de xml.dom ; implementacionDOM = xml.dom.getDOMImplementation () \n')

implementacionDOM = xml.dom.getDOMImplementation () # crea una implementacion dom basica

print ('xml.dom.EMPTY_NAMESPACE ',xml.dom.EMPTY_NAMESPACE,'\n') # devuelve el url del nombre de espacio

print ('xml.dom.XML_NAMESPACE ',xml.dom.XML_NAMESPACE,'\n') # devuelve el url del xml del nombre de espacio

print ('xml.dom.XMLNS_NAMESPACE ',xml.dom.XMLNS_NAMESPACE,'\n') # devuelve el url de LAS DECLARACIONES del nombre de espacio

print ('xml.dom.XHTML_NAMESPACE ',xml.dom.XHTML_NAMESPACE,'\n') # devuelve el url de LA DEFINICION  de xhtml 

print ('modulos propios python : modulo xml.dom.minidom ; import xml.dom.minidom \n') # presenta el tamaño del fichero indicado en la ruta

import xml.dom.minidom # importa el paquete indicado

print ('analizar una cadena xml y devuelve un documento que lo representa con parseString de xml.dom.minidom :  \n')

print ('documentoXml = xml.dom.minidom.parseString ("<mixml>algunos datos<empty/> mas datos</mixml>" \n')

documentoXml = xml.dom.minidom.parseString ("<mixml>algunos datos<empty/> mas datos</mixml>") # devuelve un documento que representa la cadena 

print ('crear un documento xml con getDOMImplementation de xml.dom.minidom ; implementarDocumento = xml.dom.minidom.getDOMImplementation () \n')

implementarDocumento = xml.dom.minidom.getDOMImplementation () # crea una implementacion minidom basica

print ('crear nuevo documento xml con createDocument de xml.dom.minidom ; nuevoDocumentoXML = implementarDocumento.createDocument (None,"<xml>",None) \n')

nuevoDocumentoXML = implementarDocumento.createDocument (None,"<xml>",None) # crea documento

print ('crear elementos con documentElement de xml.dom.minidom ; elementosDocumentos = nuevoDocumentoXML.documentElement \n')

elementosDocumentos = nuevoDocumentoXML.documentElement # elementos del documento

print ('crear node de texto con createTextNode de xml.dom.minidom ; textoNODO = nuevoDocumentoXML.createTextNode ("algun contenido textual") \n')

textoNODO = nuevoDocumentoXML.createTextNode ("algun contenido textual") # crea el nodo de texto

print ('añadir texto a elementos con appendChild de xml.dom.minidom ; elementosDocumentos.appendChild (textoNODO) \n')

elementosDocumentos.appendChild (textoNODO) # añade el nodo de texto a los elementos del documento xml 

print ('modulos propios python : modulo xml.sax ; import xml.sax \n') # presenta el tamaño del fichero indicado en la ruta

import xml.sax # importa el paquete indicado

cadenaXml = b'''<?xml version="1.0" encoding="utf-8"?>
<libro-direcciones>
 <nombre>primero pepe</nombre>
 <telefono>1238759</telefono>
 <direccion type="postal">40100, region, estado</direccion>
 <direccion type="calle">avenida, patio,puerta</direccion>
</libro-direcciones>
''' # cadena multiples lineas

print ('contenido de cadenaXml : \n')

print (cadenaXml,'\n') # presenta el contenido -simple xml-

print ('analizar una cadena xml con parseString de xml.sax ; analizarSax = xml.sax.parseString (cadenaXml,xml.sax.handler.ContentHandler()) \n')

analizarSax = xml.sax.parseString (cadenaXml,xml.sax.handler.ContentHandler()) # analiza la cadena xml -simple xml-

print ('modulos propios python : modulo xml.parsers.expat ; import xml.parsers.expat \n') # presenta el tamaño del fichero indicado en la ruta

import xml.parsers.expat # importa el paquete indicado

print ('crea y devuelve un objeto xmlparser con ParserCreate de xml.parsers.expat : \n')

print ('xmlparser = xml.parsers.expat.ParserCreate () \n')

xmlparser = xml.parsers.expat.ParserCreate () # crea y devuelve un objeto xmlparser

print ('analizar un fichero xml con ParseFile del objeto xmlparser : \n')

print ('analizadorExpat = xmlparser.ParseFile (open ("./Escritorio/ficheros5/ficheroXML.xml","rb")) \n')

analizadorExpat = xmlparser.ParseFile (open ("./Escritorio/ficheros5/ficheroXML.xml","rb")) # analiza el fichero del objeto fichero con el objeto xmlparser

print ('modulos propios python : modulo xml.etree.ElementTree ; import xml.etree.ElementTree \n') # presenta el tamaño del fichero indicado en la ruta

import xml.etree.ElementTree # importa el paquete indicado

print ('analizar fichero xml con parse de xml.etree.ElementTree ; analizadorElementTree = xml.etree.ElementTree.parse ("./Escritorio/ficheros5/ficheroXML.xml") \n')

analizadorElementTree = xml.etree.ElementTree.parse ("./Escritorio/ficheros5/ficheroXML.xml") # analiza el contenido del fichero indicado

print ('devolver los elementos del xml con getroot de xml.etree.ElementTree ; elementosXml = analizadorElementTree.getroot () \n')

elementosXml = analizadorElementTree.getroot () # devuelve los elementos del xml 

print ('iterar elementosXml ; for hijo in elementosXml \n')

for hijo in elementosXml : # iterador , bucle for in , pasa los elementos a hijo
	print ('TAG : {0:<10} ATRIBUTO : {1} \n'.format(hijo.tag,hijo.attrib)) # presenta la cadena formateada y su valor -tag y atributos tag-
else : # cuando finalice el iterador
	print ('fin contenido XML \n') # presenta el texto

print ('modulos propios python : modulo doctest ; import doctest \n') # presenta el tamaño del fichero indicado en la ruta

import doctest # importa el paquete indicado

print ('crear funcion de prueba ; test () \n')

def test () : # definicion de la funcion
	print ('LA FUNCION ; test A SIDO LLAMADA Y EJECUTADA \n') # presenta el texto
	
print ('añadir la funcion test en un comentario multilinea con ; >>> test () \n')

'''
>>> test ()
'LA FUNCION ; test A SIDO LLAMADA Y EJECUTADA'
''' # comentario multilinea

print ('ejecutar el test del comentario con testmod de doctest ; doctest.testmod () \n')

doctest.testmod () # ejecuta el test del comentario multilinea

print ('modulos propios python : modulo unittest ; import unittest \n') # presenta el tamaño del fichero indicado en la ruta

import unittest # importa el paquete indicado

print ('crear clase personalizada de prueba unittest ; class testPRUEBA (unittest.TestCase) \n')

class testPRUEBA (unittest.TestCase) : # definicion de la clase de testeo -hereda de unittest.TestCase-
	def test_llamada (self) : # definicion del metodo
		return 'testPRUEBA a sido llamado y ejecutado con su metodo test_llamada \n' # devuelve la cadena

print ('ejecutar el test de prueba ; testPRUEBA con main de unittest ; unittest.main () \n')

#unittest.main () # ejecuta la clase de prueba ; testPRUEBA -quitar almohadilla para ejecutar-

print ('modulos propios python : modulo logging ; import logging \n') # presenta el tamaño del fichero indicado en la ruta

import logging # importa el modulo indicado

print ('crear y configurar fichero log con basicConfig de logging : \n') 

print ('logging.basicConfig (filename="./Escritorio/ficheros5/logging.log",level=logging.DEBUG) \n')

logging.basicConfig (filename="./Escritorio/ficheros5/logging.log",level=logging.DEBUG) # crea y configura el fichero log 

print ('enviar mensajes al fichero log con debug de logging : \n')

print ('logging.debug ("este es el mensaje enviado al fichero log ; logging.log con debug") \n')

logging.debug ("este es el mensaje enviado al fichero log ; logging.log con debug") # envia el texto al fichero log 

print ('contenido del fichero log ; logging.log \n')

with open ("./Escritorio/ficheros5/logging.log",'r') as LOG : # abre y cierra el fichero en modo solo lectura
	print (LOG.read ()) # presenta el contenido del fichero log en una sola cadena 

print ('modulos propios python : modulo pprint ; import pprint \n') # presenta el tamaño del fichero indicado en la ruta

import pprint # importa el modulo indicado

print ('listaPrinter = ["spam","huevos","penultimo","ULTIMO","ni"] \n')

listaPrinter = ["spam","huevos","penultimo","ULTIMO","ni"] # lista

print ('insertar un elemento en la lista con insert ; listaPrinter.insert (0,listaPrinter [ : ]) \n')

listaPrinter.insert (0,listaPrinter [ : ]) # inserta en la posicion indicada la propia lista -insercion recursiva-

print ('contenido listaPrinter : ',listaPrinter,'\n') # presenta la lista modificada

print ('añadir parametros al constructor de pprint con PrettyPrinter de pprint ; imprimir = pprint.PrettyPrinter (indent=4) \n')

imprimir = pprint.PrettyPrinter (indent=4) # crea el constructor de pprint

print ('presentar datos con el formato indicado en el constructor con pprint de pprint ; imprimir.pprint (listaPrinter) \n')

imprimir.pprint (listaPrinter) # prsenta la informacion en el formato indicado en el constructor con pprint

print ('modulos propios python : modulo threading ; import threading \n') # presenta el tamaño del fichero indicado en la ruta

import threading # importa el modulo indicado

print ('devolver el numero de hilos activos con active_count de threading ; threading.active_count () ',threading.active_count (),'\n') # presenta el numero de hilos activos 

print ('devolver la constante del tiempo maximo del hilo con TIMEOUT_MAX de threading ; hilos = threading.TIMEOUT_MAX ',threading.TIMEOUT_MAX,'\n') # presenta la constante del tiempo maximo

print ('modulos propios python : modulo copy ; import copy \n') # presenta el tamaño del fichero indicado en la ruta

import copy # importa el modulo indicado

print ('devolver una copia con copy de copy ; copia = copy.copy (listaPrinter) \n')

copia = copy.copy (listaPrinter) # devuelve una copia del valor indicado

print ('copia ',copia,'\n') # presenta la copia del valor asignado

print ('devolver una copia profunda con deepcopy de copy ; copiaPROFUNDA = copy.deepcopy (listaPrinter) \n')

copiaPROFUNDA = copy.deepcopy (listaPrinter) # devuelve una copia del valor indicado

print ('copiaPROFUNDA ',copiaPROFUNDA,'\n') # presenta la copia profunda del valor asignado

print ('modulos propios python : modulo ctypes ; import ctypes \n') # presenta el tamaño del fichero indicado en la ruta

import ctypes # importa el modulo indicado

print ('crear el constructor que carga las librerias de C con cdll.LoadLibrary de ctypes ; ctypes.cdll.LoadLibrary ("libc.so.6") \n')

ctypes.cdll.LoadLibrary ("libc.so.6") # crea el constructor de la libreria indicada

print ('asignar las librerias del constructor con CDLL de ctypes ; libc = ctypes.CDLL ("libc.so.6") \n')

libc = ctypes.CDLL ("libc.so.6") # asigna las librerias cargadas

print ('libc ',libc,'\n') # presenta la instancia 

print ('uso de la libreria C en python ; libc.printf ("esta es la cadena devuelta por printf de C") \n')

if libc.printf ("esta es la cadena devuelta por printf de C \n") : # condicion , si devuelve True -1-
	print ('la funcion printf a sido EJECUTADA \n') # presenta la cadena
else : # si devuelve False -0-
	print ('la funcion printf NO a sido EJECUTADA \n') # presenta la cadena





























